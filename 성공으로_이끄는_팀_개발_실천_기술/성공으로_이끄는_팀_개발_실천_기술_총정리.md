# 성공으로 이끄는 팀 개발 실천 기술

# 문제에 어떻게 대응할까?

<aside>
💡 팀 개발을 효율적으로 진행하기 위해서는 다음과 같은 사항이 필요하다.

</aside>

- ‘무엇을’, ‘언제까지’, ‘누가’, 실행할 것인가? ‘무엇이’ 끝나면 ‘완료’ 인지를 관리하고 공유 할 것
- 소스 코드를 포함한 여러 성과물들을 팀에서 공유할 것.
- 성과물 변경을 관리하고, 성과물이 망가지지 않도록 관리하면서 각 멤버가 병행 작업이 가능할 것
- 프로젝트를 통해 얻은 지식을 팀 간에 공유할 것
- 팀에서 개발한 소프트웨어가 항상 정확하게 동작하는가를 증명할 것
- 누가 해도 실수 없이 개발, 테스트, 배포가 가능하도록 작업을 자동화 할 것

### 팀 개발 세계에서는 어디에든 통용되는 `만능 방법론이란 없다.`

- 실제 자신이 속한 프로젝트에 가장 적합한 방법을 찾아내는 것이 프로젝트의 성공의 열쇠가 된다.
- 도구 선정에 정답은 없다.

- 케이스 스터디 1일째

    ### 문제 1 : 중요한 메일이 너무 많아서 우선 순위를 정할 수 없다.

    - [중요] 에러가 발생해서 큰일입니다. 빨리 처리해 주세요.
    - [긴급] 사용 환경에서 중대한 장애 발생!!! 바로 처리해 주세요.
    - [대응필요] 중요한 고객 환경에서 디그레이드가 발생하고 있습니다. 빨리 고쳐주세요.

    모든 메일 제목에 `중요`, `긴급` 이 붙어 있어 어디서부터 손을 대야할지 모른다.

    ### 문제 2 : 검증용 환경이 없다.

    - 메일로 보고된 현상을 확인하려면 먼저 장애가 발생한 상용 환경과 동일한 환경을 구축하는 것부터 시작해야 한다. 하지만 이 프로젝트에는 검증용 환경이 애초에 존재하지 않는다.
    - 상용 환경에서 발생한 문제를 재현하려면 상용 환경과 같은 환경을 재현할 필요가 있다.

    ### 문제 3 : 폴더명으로 브랜치를 관리한다.

    - 로컬 장비에서 개발 중인 소스 코드를 ‘xxx_new’ 처럼 폴더 단위로 명칭을 만들어 두고, 버전 관리 시스템으로부터 최신 소스 코드를 체크아웃 한다. 이렇게 하지 않으면 소스 코드가 섞이게 된다.
    - VCS 에는 항상 최신 코드만 존재한다. 브랜치 관리 기능을 잘 활용하고 있지 않아서 자신의 로컬 장비에 있는 코드와 버전 관리 시스템에 있는 최신 코드를 구분하기 위한 폴더명 변경을 하고 있다.

    ### 문제 4 : 데이터베이스 재작성이 곤란

    - 데이터베이스도 상용 환경과 동일하게 만들기 위해, VCS 리포지토리에 있는 SQL을 체크아웃해서 자신의 개발 환경에 재구축해야 한다.
    -

- 케이스 스터디 1일째 의 문제점

    ### 문제 1 : 중요한 메일이 너무 많아서 우선순위를 정할 수 없다.

    - 메일 건수가 많아서 중요한 메일이 묻혀 버린다.
    - 상황 관리가 되지 않는다.
    - 일람과 검색이 어렵다.
    - 메일로 프로젝트를 관리할 때 문제

    ### 문제 2 : 검증용 환경이 없다.

    신규 개발만으로 업무가 완료되면 문제없지만, 현실에선 그렇지 않다. 배포가 끝난 환경이 있고, 다음 배포를 위한 검증용 스테이징(staging) 환경이 있으며, 더 나아가 배포를 위한 개발 환경이 있는 것이 일반적이다.

    ### 문제 3 : 폴더명으로 브랜치를 관리한다.

    VCS 를 사용하는 목적은 언제, 누가, 어떻게 변경했는지 이력을 관리하는 것(커밋 로그 관리)과 복구하고 싶은 과거의 상태로 복원하는 것(브랜치, 태그 관리) 이다.

    ### 문제 4 : 데이터베이스 재작성이 곤란

    자주 발생하는 문제는 SQL을 어떤 환경에 어디까지 적용했는지 알지 못하거나 잊어버리는 문제다.

- 케이스 스터디 2일째

    ### 문제 5 : 가동 전까지 고장 난 것을 알지 못하다

    ### 문제 6 : 다른 멤버가 수정한 것을 덮어써서 지워 버리다

    ### 문제 7 : 자신 있게 리팩토링할 수 없다.

    ### 문제 8 : 버그 수정 시기를 알 수 없어서 디그레이드 추적이 되지 않는다.

    ### 문제 9 : 브랜치 및 태그를 활용하지 못하고 있다.

    ### 문제 10 : 테스트 환경이나 상용 환경에서는 동작하지 않는다.

    ### 문제 11 : 배포가 복잡해서 메뉴얼이 필요하다.

    - VCS 에서 리포지토리의 어느 버전을 체크아웃해야 하는가?
    - DDL이나 기존 라이브러리, 설정 파일 등은 어떻게 변경해야 하는가?

    위와 같은 문제로 인해 문제가 다수 발생한다.

- 케이스 스터디 2일째 의 문제점

    ### 문제 5 : 가동 전까지 고장 난 것을 알지 못하다.

    VCS를 잘못 사용해서 다른 사람이 수정한 커밋을덮어 쓰기 한 것이 원인이다.

    커밋 로그를 일일이 추적하느라 수일이 소모될 수 있음.

    이전 처리들이 제대로 동작하는지를 체크할 수 있는 방식을 CI(지속적 통합) 라고 한다.

    - 팀 멤버 수정 내용은 물론 모든 변경 사항을 통합해서 빌드나 테스트를 제대로 통과하는지를 항상, 지속적으로 확인하는 방법이다.

    ### 문제 6 : 다른 멤버가 수정한 것을 덮어써서 지워 버리다.

    다수의 멤버가 애플리케이션을 개발하다 보면 수정 부분이 겹쳐서 충돌이 발생하는 경우도 있다. 충돌이 발생한 경우에는 양쪽 수정이 모두 동작하도록 머지해 주어야 한다.

    ### 문제 7 : 자신 있게 리팩토링할 수 없다.

    팀 멤버에 의해 몇 가지 버그 수정 커밋이 덮어쓰기 되어 버렸다. 커밋 로그를 추적해서 이것을 알아 낸 것은 좋았는데, 어떻게 수정을 하는 것이 가장 현명한 방법일까?

    이러한 경우 `리팩토링` 을 거쳐야 한다.

    **리팩토링** : 결과의 변경 없이 코드 구조를 재조정

    프로그램에 있어 무엇이 ‘바른 것’ 인지 정의해 주자.

    이를 해결하기 위한 방법 중 하나는 `사양서` 등의 문서를 만드는 것

    또한, 자신 있는 리팩토링을 수행 하기하기 위해서는 테스트 코드 작성이 중요하다.

    리팩토링을 하여 버전 관리 시스템에 커밋하기 전에 명령어 하나로 테스트를 실행해서 리팩토링 내용이 ‘바른 것’임을 알 수 있다.

    그리고 CI를 도입해서 테스트 코드를 항상 자동 실행이 가능하도록 하자. 프로그램이 ‘바른 것’ 임을 더욱 확실히 검증해서 안심하고 리팩토링 할 수 있게 된다.

    ### 문제 8 : 버그 수정 시기를 알 수 없어서 디그레이드 추적이 되지 않는다.

    장애나 버그 처리를 메일이나 구두로만 해서 팀 멤버 간에 정보 공유가 이루어지지 않으면 이런 현상이 발생한다.

    우선은 티켓 관리 시스템을 사용해서 문제 발생부터 해결까지 기록해 두는 것이 중요하다.

    또한, VCS와 티켓 관리 시스템을 연동해서 소스 코드 변경 이력과 티켓을 연관 지어 기록할 수 있다.

    ### 문제 9 : 브랜치 및 태그를 활용하지 못하고 있다.

    이것은 수정이 끝난 후 신기능을 개발하면서 머지를 잊어버릴 뻔한 예다.

    ### 문제 10 : 테스트 환경이나 상용 환경에서는 동작하지 않는다.

    환경에 따라 동작이 바뀌는 문제를 ‘환경 의존 문제’ 라고 한다.

    - 데이터베이스 스키마 차이에 따른 문제
    - 애플리케이션이 의존하는 라이브러리 설치 누락 문제
    - httpd나 memcached(멤캐시드)와 같이 환경에 따라 설정이 바뀌는 각종 미들웨어 문제

    ### 문제 11 : 배포가 복잡해서 메뉴얼이 필요하다.

    어떻게 하면 경이로운 속도로 지속적인 배포가 가능한 걸까? 적어도 메뉴얼을 사용해서 사람 손을 거쳐 배포하고 있는 것 같지는 않다.

    이것을 실현하려면 환경 의존 문제를 제어할 수 있어야 하고, 자동 테스트, 자동 배포가 가능해야 한다.

    ‘언제든지 배포 가능’한 상황을 지속적으로 유지해야 한다. 이것을 `지속적 전달(CD)` 라 한다.


## 이상적인 프로젝트란?

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/f2c6d5ce-e2d1-4757-a889-718beee17f40/fa06791e-3ba6-41b1-8786-deef25ab4f84/Untitled.png)

### 티켓 관리 시스템에 이슈 등이 집약되어 있다.

이슈나 해야할 것, 발생한 장애 등을 메일이 아닌 티켓 관리 시스템을 이용해서 한곳에서 통합 관리해야 한다.

우선순위와 중요도를 바로 알 수 있도록 관리하고, 티켓 하나하나의 상태를 바로 알 수 있는게 중요하다.

검색도 쉬워서 찾고자 하는 정보를 바로 발견할 수 있어야 하며, 과거에 발행한 티켓과 그 결과도 연동해서 찾을 수 있어야 한다.

### 가능한 버전 관리 시스템을 이용한다.

먼저, VCS를 제대로 사용해서 다른 사람이 수정한 것을 실수로 덮어 쓰기 하는 사태를 방지하도록 하자.

그리고 브랜치를 최적으로 관리해서 상용 환경에서 사용되고 있는 브랜치가 어떤 것인지, 최근 피드백용으로 사용한 브랜치는 어떤 것인지를 파악하는 것이 중요하다.

또한, 태그를 최적으로 관리해서 특정 시점의 배포 상태를 보유해 둠으로써 언제 든지 이전 상태로 복원할 수 있도록 해야 한다.

그뿐만 아니라 데이터베이스 변경 관리나 환경에 따라 바뀌는 설정 파일 관리 등도 버전 관리 시스템으로 관리한다.

### 반복 검증 가능한 CI 시스템을 도입한다

CI 시스템을 도입해서 항상 모든 리소스를 한곳에 통합할 수 있는지 빌드를 통해 확인하고, 단위 테스트를 항상 진행하는지를 체크하는 것이 중요하다.

이를 통해 커밋 누락이나 수정 잘못 등 실수하기 쉬운 부분을 바로 확인할 수 있게 되며, 이는 소프트웨어 품질 향상과 직결된다.

또한, 테스트나 빌드 스크립트를 최적으로 작성해야 한다. 최적이란, 몇 번이고 반복해서 실행 가능하고, 특정 상태에 의존하지 않으면서 같은 결과를 얻을 수 있는 것을 의미한다.

예를 들어, 데이터베이스의 상태나 환경 변수, 미들웨어 설정 등이 이에 해당한다. 이것들을 스크립트로 정리해 두면 귀찮은 데이터베이스 구축이나 기타 환경 구축을 간단히 수행할 수 있게 되며, 테스트 수행도 수월해진다.

### 환경의 영향을 최소화하고 항상 배포 가능 상태로 둔다

환경에 따른 차이를 관리하는 것은 어렵지만, 현재는 자유롭게 사용할 수 있는 여러 도구가 존재한다. 데이터베이스 변경이나 각 미들웨어 등 환경에 따라 차이가 발생할 때는 스크립트나 도구를 효율적으로 사용해서 모든 것을 버전 관리할 필요가 있다.

### 모두 기록해서 추적 가능하게 한다

언제, 누가, 어떻게 애플리케이션을 변경했는지, 어떤 이슈가 원인이 되어 발생했는지, 테스트를 통과했는지, 배포 여부 등 모든 것이 해당된다.

또한, 이런 관리가 간결하고 자연스럽게 이루어져야 하는 것이 중요하다. 종이나 엑셀을 사용해서 담당자 몇 명이 열심히 관리한다고 해서 개발 속도는 오르지 않는다. 모든 것을 자동화해서 간결하게 관리할 수 있어야 한다.

## 버전 관리 시스템

### 버전 관리 시스템이란?

버전 관리 시스템은 어떤 파일을 언제, 누가, 어떻게 변경했는지에 대한 이력을 버전으로 기록하고 관리하는 시스템이다.

### 버전 관리 시스템을 사용하면 왜 편리한 걸까?

- 변경 내용이라는 가장 기본적인 기록이 남는다.
- 버전 간 차이를 간단히 확인할 수 있다.
- 다른 사람의 변경을 실수로 덮어쓰는 사태를 방지할 수 있다.
    - Git과 같은 방식은 머지 모델에 해당한다. 머지 모델을 이용하면 다른 사람의 작업을 기다리지 않고 병행해서 개발할 수 있다는 장점이 존재한다.
    - 머지 모델 : 파일을 잠그지 않고, 개발자가 복사본을 체크하웃해서 편집한 후 리포지토리에 커밋한다. 커밋 시에 차이를 확인해서 차이가 있으면, 커밋 전에 차이를 머지한 후에 다시 커밋하도록 하는 구조다.
- 임의의 시점으로 복원이 가능하다.
    - Git 은 Changeset 기반으로 동작하며, Changeset이란 복수의 파일에 걸쳐 있는 변경을 하나로 간주할 때의 단위다.
    - 체인지셋은 하나의 묶음으로 변경을 관리하므로 과거 특정 시점의 리비전을 취득하는 경우
- 복수의 파생 데이터를 만들 수 있어서 특정 시점의 상태 데이터를 저장할 수 있다.
    - 버전 관리 시스템에는 브랜치 관리와 태그 관리라는 기능이 있다.
    - 브랜치 관리 기능을 사용함으로써 프로젝트를 여러 방향으로 분산할 수 있다.
    - 태그 관리는 리비전 번호와 별도로 파일이나 체인지셋에 임의의 이름을 붙일(태그부여) 수 있는 기능이다. 이를 통해 과거 특정 시점의 스냅샷을 관리할 수 있다.

### 분산 관리 시스템

분산 관리 시스템의 가장 큰 특징 중 하나는 중앙 리포지토리를 가지지 않는 완전한 peer to peer 모델이라는 것이다. 개발자는 소스 코드를 중앙 리포지토리에서 체크아웃 하는 것이 아니라, 리포지토리 전체를 자신의 로컬 장비에 클론(clone)해서 로컬 장비에 복사본인 리포지토리를 그대로 뷰유하게 된다.

이를 통해 네트워크를 경유하지 않고 모든 처리가 가능해서 커밋 등의 각종 명령어 실행 속도가 매우 빠르다는 특징이 있다. 또한, 로컬 리포지토리에 대한 커밋 속도가 매우 빨라서 커밋 작업에 따른 작업 실패 위험을 크게 낮춘다.

### 분산 관리 시스템의 장점

- 리포지토리의 완전한 복사본을 로컬 장비에 둘 수 있다.
- 처리 속도가 빠르다.
- 일시적인 작업에 대한 이력 관리가 쉽다.
- 브랜치, 머지가 쉽다.
- 장소에 구애받지 않고 협업이 가능하다.

### 분산 관리 시스템의 단점

- 진정한 의미의 최신 버전은 시스템상에 존재하지 않는다.
    - 중앙 리포지토리가 시스템 상에 존재하지 않기 때문에 최신 버전이라는 것이 존재 하지 않는다.
- 진정한 의미즤 리비전 번호는 없다.
    - 중앙 리포지토리가 없다는 것은 어떤 것이 최신 버전인지 알 수 없거나, 반대로 어떤 것도 최신 버전이 될 수 있다는 것을 의미한다.
- 작업 흐름을 유연하게 설정하기가 쉬워서 혼란을 야기한다.
- 개념이 익숙해지기까지 시간이 걸린다.

### 버전 관리 시스템으로 관리해야 할 것

- 소스 코드
- 요건 정의서, 설계서 등의 문서
- 데이터베이스 스키마 및 데이터
- 미들웨어 등의 설정 파일
- 라이브러리 등의 의존 관계 정의

### 태그 사용법

배포 시점을 스냅샷으로 저장할 수 있다면 편리할 것이다. 이 역할을 해 주는 것이 `태그(Tag)` 이다.

특정 시점의 스냅샷을 태그로 관리함으로써 최적의 버전 관리가 가능해지고, 장애 대응 시의 원인 판명이나 긴급 시 롤백 등에도 도움이 된다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/f2c6d5ce-e2d1-4757-a889-718beee17f40/c89bdc3a-bbd1-4072-84cd-92b4e3cc75bd/Untitled.png)

```bash
$ git tag
```

```bash
$ git show v0.1
```

## Git을 사용한 개발 흐름

### Git을 사용한 작업 흐름은 크게 다음과 같은 패턴이 있다.

- 중양 집약형 작업 흐름
    - Subversion 처럼 중앙 리포지토리를 하나 설정하고 개발 멤버 전원이 그것을 유일한 Push/Pull 대상으로 해서 로컬 장비에 클론하는 흐름.
- GitHub형 작업 흐름
    - 중앙 리포지토리를 하나 설정하는 것은 같지만, 개발 멤버 각자가 중앙 리포지토리를 Fork(포크)하거나 원격 리포지토리에서 로컬 장비에 클론 하는 흐름이다.
    - 일반적인 개발에선 Fork한 자신만의 전용 원격 리포지토리에 Push해 두고 어느 정도 진행이 된 상태에서 중앙 리포지토리에 Pull을 요청하는 방식이다.
    - 중앙 리포지토리의 정비 작업이나 머지를 기다리지 않고 병행해서 작업 진행이 가능하다.

### 브랜치 전략 패턴

- `git-flow`
    - 분산 버전 관리 시스템의 작업 흐름에 중앙 집약형 버전 관리 시스템의 장점을 가미해, 양쪽이 가진 이점을 이용한 팀 개발 흐름을 만드는 것이다.

        ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/f2c6d5ce-e2d1-4757-a889-718beee17f40/7aee5d63-a4e9-4640-a3a8-fa61c2432d30/Untitled.png)

    - 메인 브랜치
        - 중앙 리포지토리와 그것을 클론한 각 개발자 리포지토리에 의존하는 중심 브랜치
            - master : 배포를 위한 브랜치. 배포 시마다 태그를 부여함
            - develop : 개발용 브랜치. 배포 전의 최신 버전
    - 서포트 브랜치
        - 원칙상 각 개발 멤버의 리포지토리에만 의존하고 역할이 끝난 시점에 사라지는 주기가 짧은 브랜치
            - feature : develop로부터 파생되고 특정 기능 개발을 위해 작성되는 브랜치. 기능 개발이 끝나면 develop에 머지된 후 사라진다.
            - relesae : develop로부터 파생되며, 배포 준비를 위한 브랜치. 배포 준비 작업 중에 불필요한 feature가 끼어들지 못하도록 하기 위해 만들어진다. 배포가 끝나면 master와 develop에 머지된 후 사라진다.
            - hotfix : 주료 배포가 끝난 제품에 장애가 발생한 경우 긴급하게 만들어지는 브랜치. master로부터 직접 파생되며, 버그를 수정한 후 master에 머지되고 태그가 부여된다. 또한, 이 버그 수정이 장래에 누락되지 않도록 develop에도 머지한다. 만약 배포 작업 중에 release가 존재하고 있는 경우 거기에도 머지한다.
- `github-flow`
    - git-flow가 좋긴한데, 운용하기 어렵다는 점에서 나옴.
    - master는 모두 배포가 가능하다.
    - 새롭게 무언가를 할 때는 master에서 직접 브랜치를 만든다.
    - 작성한 브랜치는 로컬 장비에 커밋하고 원격 리포지토리에도 같은 이름의 브랜치로 정기적으로 Push 한다.
    - 개발이 완료되면 master에 PR한다.
    - PR이 검증됐으면 master에 머지하고 바로 상용 환경에 배포한다.
        - master는 배포용이기 때문에 직접 건드리지 않는다.
        - 작업을 시작할 때는 브랜치를 자른 후 시작한다.
        - 작업이 끝나면 master에 PR한다.
            - PR이 검증된 후 바로 머지해서 배포하므로 PR을 보내기 전에 수동으로 테스트 하거나 Jenkins 등의 CI 도구를 사용해서 자동 테스트를 상시 가동하는 것이 전제가 되어야 한다.
            - 상용 환경에 장애가 발생해도 단순히 master로부터 브랜치를 만들어서 수정하고, PR을 보내서 머지한 후 그대로 배포하기만 하면 된다.
            - GitHub 처럼 master를 항상 배포 가능한 상태로 둠으로써 운영을 단순화하는 것은 나쁘지 않은 전략이다.
- `책 저자의 절충안`
    - git-flow는 정해진 배포 기간이 있는 대규모 프로젝트용
    - github-flow는 상시 배포가 필요한 웹 서비스 등 배포 속도가 중요한 프로젝트용.
    - 개조 내용
        - GitHub를 전제로 운용한다.
        - GitHub형 작업 흐름(통합 관리형)을 채택하고, 각자가 Fork한 원격 리포지토리를 GitHub에 둔다.
        - 배포는 중앙 리포지토리의 master를 가지고 실시한다.
        - 각 개발 멤버의 로컬 장비와 자신의 원격 리포지토리는 자유롭게 관리한다.
        - 개발이 끝나면 중앙 리포지토리의 master로 PR을 보낸다
        - PR 검정을 통과하면 master에 머지
        - 배포 준비 단계에서 중앙 리포지토리의 master로부터 배포 브랜치 작성
        - 배포 브랜치상에서 회귀 테스트나 배포 테스트 등 배포를 위한 준비 작업을 한다
        - 배포 준비 작업 중에도 개발자는 신기능 개발을 master로 PR해도 된다.
        - 배포가 끝나면 master에 머지하고 master에 태그를 부여한 후 배포 브랜치를 삭제한다.

## 데이터베이스 스키마와 데이터 관리

### 데이터베이스 스키마를 관리해야 하는 이유

여러 사람이 데이터베이스 변경을 하면 SQL 운용이나 누락 순서가 달라지면서 데이터베이스 정합성이 쉽게 무너질 수 있는데도 여러 사람이 관리해야할까?

- 데이터베이스 관리자에게 변경 관리를 맡긴 경우
    - DBA에게 모든 변경 관리를 위임하면 해당 담당자의 일이 가중돼 개발 속도가 떨어질 수 있다.
- 공유 데이터베이스에서 스키마를 변경하는 경우

### 데이터베이스 스키마를 어떻게 관리하면 될까?

- 버전 관리에 필요한 요건
    - 어떤 환경이라도 동일한 순서로 데이터베이스 구축이 가능할 것
    - 반복 실행이 가능할 것
    - 텍스트 파일일 것
- 데이터베이스 마이그레이션이란?
    - 데이터베이스 스키마를 CI하는 것을 CDBI(Continuous DataBase Integration)이라 한다.
- 데이터베이스 마이그레이션 기능
    - SQL 적용 순서와 적용 범위를 관리한다.
    - 스키마 정의 편집 시 발생하는 충돌을 관리한다.
    - 롤백 구조를 준비한다.
        - 같은 파일에 롤백용 SQL도 작성해 두도록 하자.
    - 데이터 등록이 가능하도록 한다.
        - 파일에 INSERT, UPDATE 문을 작성해서 관리해두자.
- `스프링 부트` 용 방법을 아래 적어놓자.
    - `스프링 부트 전용 관리`


## 의존 관계 관리

### 의존 관리 해결 시스템

- 공통 라이브러리를 관리하는 리포지토리
- 라이브러리 의존 관계를 정의한 파일
- 이것들을 사용해서 실제 의존 관계를 해결하는 스크립트

## 티켓 관리 시스템

### 프로젝트가 제대로 돌아가지 않는 이유

- 목표가 잘못됐다.
- 견적이 부정확해서 납기가 너무 짧거나 인원이 부족하다.
- 프로젝트 종료 기준이 정의되어 있지 않다.
- 멤버의 사기가 올라가지 않고 진행이 없다.
- 프로젝트 시각화가 되어 있지 않다.
- 태스크 관리, 진척 관리, 정보 공유가 되지 않는다.

### 종이나 메일, 엑셀로 태스크를 관리할 때 문제점

종이나 엑셀로 이슈 관리를 할 경우 인력이 많아지고 해야 할 작업이 늘어나면 파탄에 이를 가능성이 높다.

이러한 경우를 해결하기 위해 티켓 관리 시스템을 도입하자.

### 티켓 관리 시스템 도입의 장점

- ‘무엇을 해야 하는가’에 대한 태스크 정의
- ‘누가 할 것인가’에 대한 담당자 배정
- ‘언제까지 할 것인가’에 대한 기한 관리
- ‘지금 상황이 어떤가? 작업중인가? 완료했는가?’ 에대한 상태 관리

- 열람성, 검색성이 높다.
    - 프로젝트의 이슈, 태스크 등을 다양한 형태로 열람할 수 있다는 것은 복잡한 프로젝트를 관리할 때 매우 중요한 기능이다.
- 정보 일괄 관리와 공유가 가능하다.
    - 과거 작업 내역이나 그것을 통해 얻은 지식 또는 프로세스 사양 등 프로젝트에 있어서 중요한 정보를 한곳에서 관리, 공유하는 것이 매우 중요하다.
- 보고서 작성에 이용할 수 있다.
    - API 너 플러그인 시스템이 존재 하는 경우 이를 이용해서 독자적으로 보고 기능을 개발할 수도 있다.
- 타 시스템과 연계가 가능해서 확장성이 높다.
    - VCS나 CI 시스템과의 연계성을 높임으로써 문제 발생부터 코드 수정 내용이나 테스트 결과, 배포 상황까지 모든 정보를 연계해서 관리하는 것이 가능하다.

### 티켓 주도 개발이란?

티켓 관리 시스템을 사용해서 티켓을 중심으로 개발 흐름을 만드는 것을 티켓 주도 개발(TiDD, Ticket Driven Development)라 한다.

`티켓이 없는 커밋을 금지` 한다는 것이다.

커밋 로그와 티켓을 반드시 일대일로 매칭햇거 코드 변경 이유를 명확히 하는 것이 티켓 주도 개발의 목적이다.

- 티켓 주도 개발의 구체적인 순서
    - 신기능 개발이나 버그 수정 시마다 해당 내용이나 목적을 기입한 티켓을 기입하는 거부터 시작된다.
    - 다음으로, 티켓 내용에 따라 적절히 코드를 수정해서 커밋한다.(커밋 로그에 관련한 티켓 번호를 넣는다. 동시에 티켓에도 커밋 로그 번호를 기입한다.)


### 도구 선정 포인트

확장성 및 편의성의 지원범위를 파악하자

## 티켓 관리 시스템과 버전 관리 시스템의 연계

티켓 관리 시스템을 도입해서 태스크 관리가 수월해지고 프로젝트가 원활히 움직이고 있다면, 버전 관리 시스템을 연동하자.

### 연계를 통해 실현 가능한 기능

- 커밋에서 티켓으로 링크
    - 소스 코드 변경으로부터 해당 변경에 대한 근거를 기록하고 있는 티켓에 이를 수 있다.
- 티켓에서 커밋으로 링크
    - 어떻게 변경되었는지를 티켓을 기준으로 찾는 방법.
- 커밋과 동시에 티켓 상태를 변경한다.
    - 버전 관리 시스템에 커밋함과 동시에 관련 티켓 상태를 변경하는 기능이다.

### GitHub 티켓 연동

커밋 메시지에 다음과 같이 issue 번호를 넣기만 하면 된다.

```bash
Fixed #21
```

이것으로 커밋에 21번 issue 링크가 연결된다. 또한, 21번 issue에 해당 커밋 로그가 링크되어 21번 issue 상태를 close로 변경한다.

- Service Hooks
    - GitHub는 리포지토리별로 다른 서비스와 연계할 수 있는 기능을 갖추고 있다. 이를 Service Hooks라 한다. Git은 코드가 Push 되는 시점에 Hook 하여 다른 서비스와 정보를 연계할 수 있다.

## 신기능 개발, 버그 수정 시 작업 흐름

### 작업 흐름

1. 티켓 발행
2. 담당자 배정
3. 개발
4. 커밋
5. 리포지토리에 Push

### 왜 이런 변경이 발생했는가? 의문 해결하기

컴파일에 실패하거나 단위 테스트에  실패한 경우에는 티켓 관리 시스템과 버전 관리 시스템의 커밋 로그부터 원인이 된 티켓을 찾아 낼 필요가 있다.

## CI(지속적 통합)

### CI란?

팀 개발 에 있어 가장 중요한 작업은?

여러 사람이 개발이나 테스트를 원활히 수행하기 위해 가장 중요한 것은 ‘통합’이다.

- 통합
- 각자 작업한 성과물을 한곳에 모아 통합하고 시스템으로 동작하는 형태가 되어야 각자의 개발 작업이 의미를 가지게 된다.
    - 모든 소스 코드를 한곳에 모은다.
    - 의존 라이브러리 등에 경로가 연결된다.
    - 필요한 경우에 컴파일한다.
    - 데이터베이스 구축과 데이터 로드를 실시한다.
    - 필요에 따라 미들웨어를 설정하거나 가동한다.
    - 단위 테스트와 통합 테스트, 사용자 테스트 등을 실시한다.
- 통합을 지속적으로 수행하는 것이 CI
    - CI는 애자일 개발 방법론의 하나로, XP 방법론으로 고안된 것이다. CI는 가치 있는 소프트웨어를 고품질로 신속하게 전달하는 것을 목표로 하는 것으로, 애자일 개발 중에서도 가장 기본이자 핵심 방법론이다.
    - 폭포수 개발에서는 개발 작업이 모두 끝나고 테스트 단계에 들어가서야 통합하는 경우가 많다. 이렇게 하면 라이브러리가 누락되고, DB 구축이 되지 않는 등의 여러 문제가 발생할 수 있다.
    - 통합 작업을 미루지 말고 개발 중에라도 실시해서 소프트웨어 개발의 복잡성을 제거하는 것이 CI의 생각 방식이다.

### 개발을 애자일화한다.

- 기존의 폭포수 모델은 요건 정의 후 설계 및 개발 후 그것을 단위 테스트, 통합 테스트, 사용자 테스트 순으로 실행한다.
    - 이렇게 하면 프로젝트 종반에 모든 것을 수정해야 할 위험이 발생할 수 있다.
- 스크럼으로 대표되는 애자일 개발에서는 반대로 접근한다. 스프린트라는 짧은 주기로 설계 및 개발과 단위 테스트, 통합 테스트, 사용자 테스트를 여러번 실시한다.
    - 스크럼에서는 스프린트별로 성과물을 내고 스플린트 리뷰라는 프로세스로 성과물을 확인한다. 그리고 이것을 피드백해서 스프린린트 작업에 반영하는 것을 반복해서 서비스를 배포한다.
    - 스플린트 후반에 처음으로 통합해서 테스트하기에는 너무 늦기 때문에 개발, 통합, 테스트를 매일 실시할 필요가 생긴다. 그래서 CI라는 접근법, 빌드와 테스트 자동화 접근법이 중요해 지는 것이다.

### 왜 CI같은 방법론이 요구되는 걸까?

- 비용 면에서 이점
    - 버그 한 건당 수정 비용은 해당 버그가 발생한 순간부터 시간 흐름에 따라 증가한다.
- 시장 변화 속도
    - 시장 속도를 따라가기 위해서는 어느 정도 가독성이나 유지관리에 대한 측면을 초기 단계부터 희생할 수도 있을 것이다.
- 속도와 품질 둘 다 확보하려면 …
    - 제품에 대해 API 수준의 동작만 보장하도록 최소한의 테스트를 작성해서 CI를 실시하고, 코드 내용은 동작하는 수준까지만 해 두고 시장 출시를 먼저 하는 방법도 있다.
    - 이후 무사히 제품 사용이 가능해지면 앞 단계에서 희생했던 가독성과 유지관리를 고려한 코드로 바꾸는 것이다.
    - 초기 속도를 중심해서 빠르게 시장에 출시하는 것에 중점을 두고 나중에 리팩토링을 통해 유지관리 효율성을 높이는 것이다.

### CI에 필요한 것!

- 버전 관리 시스템
- 빌드 도구
- 테스트 코드
- CI 도구

### 주요 CI 도구

- Jenkins
- Travis CI

## 테스트 코드

개발 속도와 품질 향상에 크게 기여하는 것이 CI를 통한 자동 테스트, 이를 실행하기 위해서는 테스트 코드를 작성해야 한다.

### CI 대상이 되는 테스트 종류

- 단위 테스트
- 통합 테스트
- 사용자 테스트
- 회귀 테스트

### 테스트 코드를 언제 작성할 것인가?

- 신규 프로젝트를 시작하는 경우
    - 새롭게 클래스를 만들거나 메소드를 추가할 때마다 반드시 테스트 코드도 함께 작성해서 버전 관리 시스템에 함께 커밋하자.
    - 개발자가 하는 일은 단순히 코드를 작성하면 끝나는 것이 아니라 고객에게 가치를 전달하는 것이기 때문에 테스트 코드는 필수이다.
- 기존 프로젝트에 테스트가 없는 경우
    - 적절히 클래스가 분할되어 있지 않거나, RDBMS 또는 외부 시스템 API와 강결합이 되어있어 애플리케이션 전체를 시작하지 않으면 동작 확인이 어려운 경우 우선 가장 바깥쪽부터 동작을 확인하는 테스트 코드를 작성하도록 한다. 가장 바깥쪽은 UI 부분을 의미한다.
    - Selenium을 이용해서 브라우저 UI를 통한 사용자 테스트를 작성, 자동화 해버리자.
    - 이를 통해 반복 회귀 테스트를 작성할 수 있고, 디그레이드를 신경 쓰지 않고 소스 코드를 리팩토링 할 수 있다.
    - Selenium으로 외부를 강화하고 나서 내부를 테스트 가능한 클래스로 여유롭게 변경하면, 품질이 향상될 뿐 아니라 신기능 추가 속도도 빨라진다.
- 버그 수정 또는 신기능을 추가한 경우
    - 처음부터 테스트 코드를 작성해서 레거시 코드가 된 프로젝트이든, 버그 수정이나 신기능 추가 시점에서는 새로운 소스코드를 추가해야한다. 이 시점에서 반드시 테스크 코드를 작성해야 한다.

### 복잡한 테스트는 어떻게 작성할까?

RDBMS나 외부 시스템 API와 결합과 같이 테스트 하기 어려운 부분은 어떻게 테스트 해야할까?

- 외부와 연계돼 있는 부분 테스트
- 모킹 프레임워크를 사용해서 테스트
    - CI에서 같은 테스트를 지속적으로 반복해서 실행하기 위해서는 언제 실행하든지 동일한 결과를 얻을 수 있어야 한다. 데이터베이스는 상태를 유지하기 위한 것이기 때문에 테스트를 반복하다 보면 데이터베이스 상태가 바뀐다. 이것을 방지하기 위한 방법 중 하나가 모크다.
    - 모킹 프레임워크를 사용하지 않으면 테스트 시마다 데이터베이스를 가동해서 데이터베이스를 작성하고 테이블을 CREATE해서 데이터를 등록해야 한다.
    - Selenium을 사용한 사용자 테스트를 실시할 경우 모크를 사용하는 것보다 실제 데이터베이스를 사용해서 테스트 하는 것이 더 좋다.
    - 사용자 테스트는 데이터베이스 접속 성공 여부를 테스트하거나, 테이블 간 복잡한 상태 전이도 테스트하고 싶은 경우가 많기 때문이다.
    - 또한 사용자 테스트의 경우는 관련 객체를 모두 모크화 하려면 레코드 수나 테이블 수가 너무 많아서 비현실 적인 경우가 많다.
- 인메모리 데이터베이스를 사용한 테스트
- 데이터베이스 변경 관리나 설정 관리 테스트
    - 데이터베이스 구축 후 간단한(Smoke) 테스트를 작성해서 애플리케이션 요소가 정체 없이 동작하는지를 확인할 수 있다.
    - 환경 구축 부분 테스트도 같은 방법으로 작성해 두는 것이 좋다.
    - 미들웨어를 가동한 후 접속 여부를 확인하는 간단한 테스트를 작성해 두면 도움이 된다.
- 복잡한 테스트는 기간에 반비례
    - 외부와 연계된 테스트나 데이터베이스 변경 관리, UI를 동반하는 테스트 등 작성이 복잡한 테스트는 당연한 얘기지만 시간도 많이 걸린다.
    - 프로젝트의 요구사항에 맞춰 적절하게 테스트 작성을 하자.

### Jenkins로 무엇을 할 수 있을까?

Jenkins는 CI를 지원하기 위한 도구로, 플러그인을 조합해서 방대한 기능을 제공한다.

- 소스 코드를 체크아웃
- 자동으로 빌드 및 테스트 실행
- 결과를 집계한 보고서
- 통지

### 잡 신규 작성

Jenkins는 Job이라는 단위로 일련의 처리를 관리한다. 하나의 애플리케이션에 하나의 잡, 또는 하나의 리포지토리에 하나의 잡이라 생각해보자.

### 소스 코드를 체크아웃 한다.

버전 관리로부터 소스 코드를 체크아웃하기 위한 설정을 한다. 버전 관리에 저장하는 것은 소스 코드만 있는 것이 아니다. 데이터베이스 스키마 정의나 설정 파일 등 애플리케이션 가동에 필요한 모든 것이 해당된다.

### 자동 빌드 및 테스트 실행

빌드 설정을 해보자. ‘구성’ 메뉴에서 ‘빌드 유발’ 과 ‘Build’ 부분을 조정하면 된다. ‘빌드 유발’에서는 빌드를 실행할 트리거(Trigger)를 설정한다.

- 정기 실행(Build peroidically)
    - 1일 1회, 4시간 마다 1회 등의 형식으로 정기적으로 자동 빌드를 실행하는 설정이다. cron 형식으로 빈도를 지정할 수 있다.
    - 일간 빌드는 엄밀히 말하면 CI는 아니지만 설정이 간단해서 쉽게 실시할 수 있는 기법이다.
- 버전 관리 시스템을 폴링(Poll SCM)
    - 버전 관리 시스템을 폴링(polling)으로 감시해서 새로운 커밋(Push)이 있을 때 빌드를 실행하도록 설정한다.
    - 폴링 빈도를 cron 서식으로 지정할 수 있다.
    - 폴링이기 때문에 커밋 유무에 상관없이 관리 시스템에 따라 리퀘스트를 던진다. 시스템에 부하를 주긴하지만, 문제가 되지 않는 한도내에서 손쉽게 CI를 실시할 수 있다.
    - 가능한 정기 실행이 아닌 커밋 시마다 빌드가 가능하도록 CI를 실시하는 것이 중요하다.

### 결과를 집계해서 보고서 출력

### 커버리지 측정

어느정도 테스트 코드를 작성해야 하는지를 시각화.

### 정적 분석

자동 테스트와 같이 코드 커버리지 측정에 추가적으로 소스 코드 정적 분석을 포함하면 품질 향상을 기대할 수 있따.

- CheckStyle
- Findbugs

정적 분석을 CI에서 수행하면 코드 리뷰 시에 부담이 줄어즌다.

### 통지 설정

## 통지 운용

### 빌드가 망가지면 어떻게 하나?

- Git 과 관련한 버전 관리 시스템
    - 빌드가 망가지면 해당 시점의 동일 리포지토리, 동일 브랜치에서 작업하고 있는 모든 멤버의 커밋을 중지하는 것이 원활한 운용을 위한 지름길이다.
- 테스트 후에 머지한다.
    - Travis CI와 GitHub를 조합하면 테스트한 후 머지가 가능하다.

### 추적 가능성 확보

빌드가 망가지거나 어떤 이유로 문제가 발생했을 때 문제가 발생한 빌드가 어느 커밋에 의해 영향을 받았는지, 그리고 그 커밋이 어떤 근거로 실행됐는지 등을 추적할 수 있다면 운용에 도움이 된다.

Jenkins를 티켓 관리 시스템이나 버전 관리 시스템과 연계함으로써 추적 가능성(traceability)를 확보하고 프로젝트 시각화를 실현 할 수 있다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/f2c6d5ce-e2d1-4757-a889-718beee17f40/533e88ce-7c75-447f-abe3-9913e41d5c25/Untitled.png)

- 빌드와 커밋을 연계한다
    - 망가진 빌드가 있따면 그 원인 제공자가 누구인지와 해당 내용까지 한눈에 파악할 수 있다.
- 티겟 관리와 연동한다.